---
interface Logo {
  src: string
  alt?: string
  scale?: number // 0.8â€“1 recommended; >1 is clamped to 1
}

const {
  title,
  heightPx = 56,
  speed = '45s',
  gapRem = 8,
  gray = true,
  className = ''
} = Astro.props as {
  title?: string
  heightPx?: number
  speed?: string
  gapRem?: number
  gray?: boolean
  className?: string
}

const logos: Logo[] = [
  { src: '/logos/clients/contera_logo.svg', alt: 'Contera', scale: 0.5 },
  { src: '/logos/clients/corwin_logo.svg', alt: 'Corwin', scale: 0.5 },
  { src: '/logos/clients/JTRE.svg', alt: 'Corwin', scale: 0.5 },
  { src: '/logos/clients/lucron_logo.svg', alt: 'Lucron' },
  { src: '/logos/clients/panattoni_logo.svg', alt: 'Panattoni', scale: 0.8 },
  { src: '/logos/clients/penta_logo.svg', alt: 'Penta', scale: 0.8 },
  { src: '/logos/clients/reinoo_logo.svg', alt: 'Reinoo', scale: 0.8 },
  { src: '/logos/clients/saint_gobain.svg', alt: 'Saint Gobain' },
  { src: '/logos/clients/vgp_logo.svg', alt: 'VGP' }
]
---

<section class={`py-4 ${className}`}>
  <div class='container-fluid px-0'>
    {
      title && (
        <div class='row mb-3'>
          <div class='col'>
            <h2 class='h6 text-secondary text-center m-0'>{title}</h2>
          </div>
        </div>
      )
    }

    <div class='marquee' style={`--h:${heightPx}px; --gap:${gapRem}rem; --speed:${speed};`}>
      <div class='belt'>
        <!-- Segment A (measured) -->
        <div class='segment'>
          {
            logos.map(({ src, alt, scale }) => (
              <div class={`item${gray ? ' gray' : ''}`} style={`--s:${Math.min(scale ?? 1, 1)};`}>
                <img src={src} alt={alt ?? ''} loading='eager' decoding='async' />
              </div>
            ))
          }
        </div>
        <!-- Segment B (duplicate, not measured) -->
        <div class='segment' aria-hidden='true'>
          {
            logos.map(({ src, alt, scale }) => (
              <div class={`item${gray ? ' gray' : ''}`} style={`--s:${Math.min(scale ?? 1, 1)};`}>
                <img src={src} alt='' loading='lazy' decoding='async' />
              </div>
            ))
          }
        </div>
      </div>

      <!-- Inline browser JS (no TS casts), inside .marquee -->
      <script is:inline>
        ;(function () {
          var root = document.currentScript && document.currentScript.closest('.marquee')
          if (!root) return
          var belt = root.querySelector('.belt')
          var segA = root.querySelector('.segment') // first segment only

          function measure() {
            if (!segA) return
            // scrollWidth includes padding-right seam; round to avoid subpixel drift
            var segWidth = Math.ceil(segA.scrollWidth || segA.getBoundingClientRect().width)
            root.style.setProperty('--seg', segWidth + 'px')
          }

          function start() {
            measure()
            root.classList.add('is-ready') // enables CSS animation
          }

          // Wait for FIRST segment images only (dup may stay lazy/offscreen)
          var imgs = segA.querySelectorAll('img')
          var pending = imgs.length
          if (pending === 0) start()
          imgs.forEach(function (img) {
            if (img.complete) {
              pending--
              if (pending === 0) start()
            } else {
              img.addEventListener(
                'load',
                function () {
                  pending--
                  if (pending === 0) start()
                },
                { once: true }
              )
              img.addEventListener(
                'error',
                function () {
                  pending--
                  if (pending === 0) start()
                },
                { once: true }
              )
            }
          })

          // Re-measure on resize (container or viewport)
          var ro = new ResizeObserver(function () {
            measure()
          })
          ro.observe(root)
        })()
      </script>
    </div>
  </div>
</section>

<style>
  .marquee {
    overflow: hidden;
    width: 100%;
    height: var(--h);
  }

  /* Belt: animate only after measuring (--seg) */
  .belt {
    display: flex;
    align-items: center;
    width: max-content;
    will-change: transform;
    animation: none;
  }
  .marquee.is-ready .belt {
    animation: scroll var(--speed) linear infinite;
  }

  /* Two segments back-to-back; add explicit seam gap after the first segment */
  .segment {
    display: flex;
    align-items: center;
  }
  .segment:first-child {
    padding-right: var(--gap);
  }

  .item {
    flex: 0 0 auto;
    height: var(--h);
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
    margin-right: var(--gap);
  }
  .item:last-child {
    margin-right: 0;
  }

  .item img {
    display: block;
    height: clamp(0px, calc(var(--h) * var(--s, 1)), var(--h));
    width: auto;
    max-height: var(--h);
    object-fit: contain;
  }

  .item.gray img {
    filter: invert(46%) sepia(0%) saturate(0%) hue-rotate(0deg) brightness(90%) contrast(85%);
    opacity: 0.35;
  }

  @media (prefers-reduced-motion: reduce) {
    .marquee .belt {
      animation: none !important;
    }
  }

  @keyframes scroll {
    from {
      transform: translate3d(0, 0, 0);
    }
    to {
      transform: translate3d(calc(-1 * var(--seg, 0px)), 0, 0);
    }
  }
</style>
