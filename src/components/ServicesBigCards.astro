---
interface Service {
  title: string
  desc: string
  href?: string
}
interface Props {
  heading?: string
  services: Service[]
  cols?: number
}
const { heading = 'Naše služby', services = [], cols = 3 } = Astro.props

const colsSafe = Math.min(Math.max(cols, 1), 4)

// chunk into visual rows of colsSafe (for borders + subgrid rows)
function chunk<T>(arr: T[], n: number): T[][] {
  const out: T[][] = []
  for (let i = 0; i < arr.length; i += n) out.push(arr.slice(i, i + n))
  return out
}
const rows = chunk(services, colsSafe)
---

<section class='my-6'>
  <header class='row mb-1'>
    <div class='col-12 col-lg-8'>
      <h2 class='text-gray-300 display-1 fw-bold lh-1 mb-0'>{heading}</h2>
    </div>
  </header>

  <div class='services-frame'>
    {
      rows.map((group) => (
        <div class='services-row' style={`--cols:${colsSafe};`}>
          {group.map((s) => (
            <article class='service-cell'>
              <h3 class='service-title fw-bold' data-aos='fade-up' data-aos-duration='1500'>
                {s.href ? (
                  <a href={s.href} class='text-decoration-none service-link'>
                    {s.title}
                  </a>
                ) : (
                  s.title
                )}
              </h3>

              <div class='reveal' data-aos='fade-up' data-aos-duration='2000'>
                <p class='service-desc text-body-secondary mb-0'>{s.desc}</p>
              </div>
            </article>
          ))}
          {Array.from({ length: Math.max(0, colsSafe - group.length) }).map(() => (
            <div class='service-cell service-cell--empty' aria-hidden='true' />
          ))}
        </div>
      ))
    }
  </div>
</section>

<style>
  .my-6 {
    margin-block: clamp(3rem, 6vw, 6rem) !important;
  }

  .services-frame {
    border-bottom: 1px solid var(--bs-border-color);
  }

  .services-row {
    display: grid;
    grid-template-columns: 1fr;
    grid-template-rows: [title] max-content [desc] 1fr;
    row-gap: 0;
    column-gap: 3rem;
    border-top: 1px solid var(--bs-border-color);
  }

  .service-cell {
    display: block;
    padding-block: 2rem;
    overflow: hidden;
    position: relative;
    border-bottom: 1px solid var(--bs-border-color);
  }
  .service-title {
    margin: 0;
    font-size: clamp(1.5rem, 2vw + 1rem, 2.25rem);
    line-height: 1.2;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }
  .reveal {
    will-change: transform, opacity;
  }
  .service-desc {
    margin-top: 0.75rem;
    font-size: 1rem;
    line-height: 1.55;
    max-width: 60ch;
  }

  .service-link {
    color: inherit;
    transition: color 0.2s;
  }
  .service-link:hover,
  .service-link:focus {
    color: var(--bs-primary);
    text-decoration: none;
  }

  .service-cell--empty {
    display: none;
  }

  .text-gray-300 {
    color: var(--bs-gray-300);
  }

  :root[data-bs-theme='dark'] .service-desc {
    color: var(--bs-gray-300);
  }

  @media (min-width: 768px) {
    .services-row {
      grid-template-columns: repeat(var(--cols, 3), minmax(0, 1fr));
    }
    .service-cell {
      display: grid !important;
      grid-template-rows: subgrid;
      grid-row: span 2;
      grid-auto-flow: row;
      border-bottom: 0;
    }
    .service-title {
      grid-row: title;
    }
    .reveal {
      grid-row: desc;
    }
  }

  @media (max-width: 767.98px) {
    .services-row {
      border-top: 0;
    }
    .services-frame {
      border-bottom: 0;
    }
  }

  /* Fallback if subgrid isn't supported (still aligns nicely) */
  @supports not (grid-template-rows: subgrid) {
    @media (min-width: 768px) {
      .service-cell {
        display: block !important;
      }
      .service-title {
        min-height: calc(2 * 1lh);
      }
    }
  }
</style>
